'''
Pyomo Optimizer

This program takes .dat inputs generated by the
csv_to_dat converter and runs them in a linear
optimization model using pyomo and the glpk
solver.

Code adapted from "Named Generic Abstract Solver"
demonstrated by Michael Gorbunov 2022;
Allows sets' indicies to be named

New Jersey Forest Service 2022
'''
import sys
import pyomo.environ as pyo

#Colab mount Google Drive and map paths
from google.colab import drive
drive.mount('gdrive')
#Google drive paths
COLABPATH = 'gdrive/My Drive/Colab Notebooks/'
DATAPATH = 'gdrive/My Drive/Colab Notebooks/data/'
#add COLABPATH to system path to load classes
#and custom modules
sys.path.insert(0, COLABPATH)

#Path for input file
filepath = DATAPATH+'SLmonthly_1.dat'

# In Python2, integer divisions truncate values (1/2 = 0 instead of 0.5)
# which breaks the solver. Either way, we should be using python3
if (sys.version[0] != '3'):
	print("You are not using python 3, so this will fail")
	sys.exit(1)

# Below we instantiate the model
model = pyo.AbstractModel()
model.index_vars = pyo.Set()
model.index_le_consts = pyo.Set()
model.index_ge_consts = pyo.Set()
model.index_eq_consts = pyo.Set()

model.x = pyo.Var(model.index_vars, domain=pyo.NonNegativeReals)

# These guys are read from input.dat
model.vec_objective = pyo.Param(model.index_vars)

model.mat_le = pyo.Param(model.index_le_consts, model.index_vars)
model.vec_le = pyo.Param(model.index_le_consts)

model.mat_ge = pyo.Param(model.index_ge_consts, model.index_vars)
model.vec_ge = pyo.Param(model.index_ge_consts)

model.mat_eq = pyo.Param(model.index_eq_consts, model.index_vars)
model.vec_eq = pyo.Param(model.index_eq_consts)

#Defining the actual functions
def obj_function(_model):
	return pyo.summation(_model.vec_objective, _model.x)

def le_mat_rule (_model, k):
	return sum(_model.mat_le[k, i] * _model.x[i] for i in _model.index_vars) <= _model.vec_le[k]

def ge_mat_rule (_model, k):
	return sum(_model.mat_ge[k, i] * _model.x[i] for i in _model.index_vars) >= _model.vec_ge[k]

def eq_mat_rule (_model, k):
	return sum(_model.mat_eq[k, i] * _model.x[i] for i in _model.index_vars) == _model.vec_eq[k]

model.OBJ = pyo.Objective(rule=obj_function, sense=pyo.maximize)
model.GEConstraint = pyo.Constraint(model.index_ge_consts, rule=ge_mat_rule)
model.LEConstraint = pyo.Constraint(model.index_le_consts, rule=le_mat_rule)
model.EQConstraint = pyo.Constraint(model.index_eq_consts, rule=eq_mat_rule)

# Now read data file
instance = model.create_instance(filename=filepath)
solved_model = pyo.SolverFactory('glpk')

# Now optimize
results = solved_model.solve(instance)

#print outputs
'''
This part of the program could use improvements;
process some of this information into outputfiles
or databases
'''
print()
print(instance.OBJ.pprint())
print(instance.EQConstraint.pprint())
print(instance.GEConstraint.pprint())
print(instance.LEConstraint.pprint())

print('\n\n==== Nicer Formatting ====')

for v in instance.component_objects(pyo.Objective, active=True):
	print("Objective Value: ", pyo.value(v))

print()
print("Decision Variables")
for v in instance.component_objects(pyo.Var, active=True):
	for index in v:
		print(index, " ", pyo.value(v[index]))
