'''
Pyomo Optimizer

This program takes .dat inputs generated by the
csv_to_dat converter and runs them in a linear
optimization model using pyomo and the glpk
solver.

Code adapted from "Named Generic Abstract Solver"
demonstrated by Michael Gorbunov 2022;
Allows sets' indicies to be named

New Jersey Forest Service 2022
'''
import sys
import pyomo.environ as pyo

#Path for input file
filepath = '/home/velcro/Documents/Professional/NJDEP/TechWork/ForMOM/MiniModelRunning/run2/out.dat'
# filepath = '../convert_to_dat/sample_data/SLmonthly1_out.dat'

# In Python2, integer divisions truncate values (1/2 = 0 instead of 0.5)
# which breaks the solver. Either way, we should be using python3
if (sys.version[0] != '3'):
	print("You are not using python 3, so this will fail")
	sys.exit(1)

# Below we instantiate the model
model = pyo.AbstractModel()
model.index_vars = pyo.Set()
model.index_le_consts = pyo.Set()
model.index_ge_consts = pyo.Set()
model.index_eq_consts = pyo.Set()

model.x = pyo.Var(model.index_vars, domain=pyo.NonNegativeReals)

# These guys are read from input.dat
model.vec_objective = pyo.Param(model.index_vars)

model.mat_le = pyo.Param(model.index_le_consts, model.index_vars)
model.vec_le = pyo.Param(model.index_le_consts)

model.mat_ge = pyo.Param(model.index_ge_consts, model.index_vars)
model.vec_ge = pyo.Param(model.index_ge_consts)

model.mat_eq = pyo.Param(model.index_eq_consts, model.index_vars)
model.vec_eq = pyo.Param(model.index_eq_consts)

#Defining the actual functions
def obj_function(_model):
	return pyo.summation(_model.vec_objective, _model.x)

def le_mat_rule (_model, k):
	return sum(_model.mat_le[k, i] * _model.x[i] for i in _model.index_vars) <= _model.vec_le[k]

def ge_mat_rule (_model, k):
	return sum(_model.mat_ge[k, i] * _model.x[i] for i in _model.index_vars) >= _model.vec_ge[k]

def eq_mat_rule (_model, k):
	return sum(_model.mat_eq[k, i] * _model.x[i] for i in _model.index_vars) == _model.vec_eq[k]

model.OBJ = pyo.Objective(rule=obj_function, sense=pyo.maximize)
model.GEConstraint = pyo.Constraint(model.index_ge_consts, rule=ge_mat_rule)
model.LEConstraint = pyo.Constraint(model.index_le_consts, rule=le_mat_rule)
model.EQConstraint = pyo.Constraint(model.index_eq_consts, rule=eq_mat_rule)

# Now read data file
instance = model.create_instance(filename=filepath)

# Add duals (shadow cost) info 
# ong I have no idea why duals are the same as shadow costs, but they are so we good
instance.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT_EXPORT)

solver = pyo.SolverFactory('glpk')

# Now optimize
results = solver.solve(instance, tee=True)
print("\n" * 5)

# Check status of model
status = results.solver.status
termination_cond = results.solver.termination_condition

print(f"Solve attempted")
print(f"Status: {status}")
print(f"Termination Condition: {termination_cond}")
print("\n" * 5)

if (termination_cond != pyo.TerminationCondition.optimal):
	print(" [[ ERROR ]]: Solve ended without optimal solution")
	print("\taborting")
	sys.exit(0)



# Get variable values
decvars = instance.x.keys()
decvars_values = {str(k): pyo.value(instance.x[k]) for k in decvars}
decvars = list(decvars_values.keys())

# Pg. 14 - 22 of this textbook on optimization are really handy http://web.mit.edu/15.053/www/AMP-Chapter-01.pdf

# Slack & Shadow Price extraction 
# 
# Courtesy of this stack overflow
# https://stackoverflow.com/questions/65523319/pyomo-accesing-retrieving-dual-variables-shadow-price-with-binary-variables

shadow_prices = {str(key).split("[")[1][:-1]: instance.dual[key] for key in instance.dual.keys()}
shadow_keys = list(shadow_prices.keys())

# Extracting Slack Amounts
ge_keys = instance.GEConstraint.keys()
ge_slack = {str(key): instance.GEConstraint[key].lslack() for key in ge_keys}
ge_keys = list(ge_slack.keys())

le_keys = instance.LEConstraint.keys()
le_slack = {str(key): instance.LEConstraint[key].uslack() for key in le_keys}
le_keys = list(le_slack.keys())

# Now actual output
print("\n\n == Variables")
[print("%-20s | %s" % (k, decvars_values[k])) for k in decvars]

print("\n\n == Shadow Prices")
[print("%-40s | %s" % (k, shadow_prices[k])) for k in shadow_keys]

print("\n\n == Slacks for GE")
[print("%-40s | %s" % (k, ge_slack[k])) for k in ge_keys]

print("\n\n == Slacks for LE")
[print("%-40s | %s" % (k, le_slack[k])) for k in le_keys]
