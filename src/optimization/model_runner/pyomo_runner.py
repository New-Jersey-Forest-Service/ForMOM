'''
Pyomo Optimizer

This program takes .dat inputs generated by the
csv_to_dat converter and runs them in a linear
optimization model using pyomo and the glpk
solver.

Code adapted from "Named Generic Abstract Solver"
demonstrated by Michael Gorbunov 2022;
Allows sets' indicies to be named

New Jersey Forest Service 2022
'''
import sys
from typing import Union
import pyomo.environ as pyo
import pyomo.opt as opt

#Path for input file
filepath = '/home/velcro/Documents/Professional/NJDEP/TechWork/ForMOM/MiniModelRunning/run2/out.dat'
# filepath = '../convert_to_dat/sample_data/SLmonthly1_out.dat'

# In Python2, integer divisions truncate values (1/2 = 0 instead of 0.5)
# which breaks the solver. Either way, we should be using python3
if (sys.version[0] != '3'):
	print("You are not using python 3, so this will fail")
	sys.exit(1)



def loadPyomoModelFromDat (datFilepath: str) -> pyo.ConcreteModel:
	# Below we instantiate the model
	model = pyo.AbstractModel()
	model.index_vars = pyo.Set()
	model.index_le_consts = pyo.Set()
	model.index_ge_consts = pyo.Set()
	model.index_eq_consts = pyo.Set()

	model.x = pyo.Var(model.index_vars, domain=pyo.NonNegativeReals)

	# These guys are read from input.dat
	model.vec_objective = pyo.Param(model.index_vars)

	model.mat_le = pyo.Param(model.index_le_consts, model.index_vars)
	model.vec_le = pyo.Param(model.index_le_consts)

	model.mat_ge = pyo.Param(model.index_ge_consts, model.index_vars)
	model.vec_ge = pyo.Param(model.index_ge_consts)

	model.mat_eq = pyo.Param(model.index_eq_consts, model.index_vars)
	model.vec_eq = pyo.Param(model.index_eq_consts)

	#Defining the actual functions
	def obj_function(_model):
		return pyo.summation(_model.vec_objective, _model.x)

	def le_mat_rule (_model, k):
		return sum(_model.mat_le[k, i] * _model.x[i] for i in _model.index_vars) <= _model.vec_le[k]

	def ge_mat_rule (_model, k):
		return sum(_model.mat_ge[k, i] * _model.x[i] for i in _model.index_vars) >= _model.vec_ge[k]

	def eq_mat_rule (_model, k):
		return sum(_model.mat_eq[k, i] * _model.x[i] for i in _model.index_vars) == _model.vec_eq[k]

	model.OBJ = pyo.Objective(rule=obj_function, sense=pyo.maximize)
	model.GEConstraint = pyo.Constraint(model.index_ge_consts, rule=ge_mat_rule)
	model.LEConstraint = pyo.Constraint(model.index_le_consts, rule=le_mat_rule)
	model.EQConstraint = pyo.Constraint(model.index_eq_consts, rule=eq_mat_rule)

	# Now read data file
	# instance = model.create_instance(filename=datFilepath)
	instance = model.create_instance(filename=filepath)

	# Add duals (shadow cost) info 
	# ong I have no idea why duals are the same as shadow costs, but they are so we good
	instance.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT_EXPORT)

	return instance


def solveConcreteModel (instance: pyo.ConcreteModel) -> Union[pyo.ConcreteModel, opt.SolverResults]:
	'''
		Solves the passed in modle (mutates it), and returns
		the concrete model + the solver results
	'''
	solver = pyo.SolverFactory('glpk')

	# Now optimize
	results = solver.solve(instance, tee=True)

	return instance, results


def getOutputStr (instance: pyo.ConcreteModel, results: opt.SolverResults) -> str:
	rstr = ''

	# Check status of model
	status = results.solver.status
	termination_cond = results.solver.termination_condition

	rstr += f"Solve attempted\n"
	rstr += f"Status: {status}\n"
	rstr += f"Termination Condition: {termination_cond}\n"
	rstr += "\n" * 5

	if (termination_cond != pyo.TerminationCondition.optimal):
		rstr += " [[ ERROR ]]: Solve ended without optimal solution\n"
		rstr += "\taborting"
		return rstr



	# Get variable values
	decvars = instance.x.keys()
	decvars_values = {str(k): pyo.value(instance.x[k]) for k in decvars}
	decvars = list(decvars_values.keys())

	# Pg. 14 - 22 of this textbook on optimization are really handy http://web.mit.edu/15.053/www/AMP-Chapter-01.pdf

	# Slack & Shadow Price extraction 
	# 
	# Courtesy of this stack overflow
	# https://stackoverflow.com/questions/65523319/pyomo-accesing-retrieving-dual-variables-shadow-price-with-binary-variables

	shadow_prices = {str(key).split("[")[1][:-1]: instance.dual[key] for key in instance.dual.keys()}
	shadow_keys = list(shadow_prices.keys())

	# Extracting Slack Amounts
	ge_keys = instance.GEConstraint.keys()
	ge_slack = {str(key): instance.GEConstraint[key].lslack() for key in ge_keys}
	ge_keys = list(ge_slack.keys())

	le_keys = instance.LEConstraint.keys()
	le_slack = {str(key): instance.LEConstraint[key].uslack() for key in le_keys}
	le_keys = list(le_slack.keys())

	# Now actual output
	rstr += "\n\n == Variables\n"
	rstr += "\n".join(["%-20s | %s" % (k, decvars_values[k]) for k in decvars])

	rstr += "\n\n == Shadow Prices\n"
	rstr += "\n".join(["%-40s | %s" % (k, shadow_prices[k]) for k in shadow_keys])

	rstr += "\n\n == Slacks for GE\n"
	rstr += "\n".join(["%-40s | %s" % (k, ge_slack[k]) for k in ge_keys])

	rstr += "\n\n == Slacks for LE\n"
	rstr += "\n".join(["%-40s | %s" % (k, le_slack[k]) for k in le_keys])

	return rstr










if __name__ == '__main__':
	instance = loadPyomoModelFromDat(filepath)
	instance, res = solveConcreteModel(instance)
	resStr = getOutputStr(instance, res)

	print(resStr)

